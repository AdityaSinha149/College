![[4.12.png]]
### 4.4.1 Datagram Format ^datagramformat
![[4.13.png]]
- **Version number** : These 4 bits specify the version of datagram. IPv4 and IPv6 use different datagram formats.
- **Header length** : Because IPv4 datagram can have many options, these 4 bits tell where the data in the datagram actually begins from. Most datagrams don't contain any options and have a 20 byte header.
- **Type of Service** : It is included in IPv4 header, it is used to allow different type of datagrams like datagram particularly requiring low delay to be distinguished from each other. For example it might be useful to distinguish real time traffic telephone datagrams from non real time traffic ftp datagrams.
- **Datagram Length** : This is the total length of the IP datagram (header plus data), measured in bytes. Since this field is 16 bits long, the theoretical maximum size of the IP datagram is 65,535 bytes.
- **Identifier, flags, fragmentation offset** : These three fields have to do with so-called IP fragmentation, a topic we will consider in depth shortly. Interestingly, the new version of IP, IPv6, does not allow for fragmentation at routers.
- **Time-to-live** : TTL field is included to ensure that the datagram don't circulate forever in the network. The field is decremented by 1 each time it is processed by a router and is dropped when the field reaches 0.
- **Protocol** : This field is used only at the final destination. It tells the specific transport layer protocol to which the ip datagram should be passed. For example a value 6 indicates that the data is passed to TCP.
  *Protocol number glues network layer with transport layer and port number glues transport layer to application layer*
- **Header checksum** : It aids the router in error detection. It is computed by treating each 2 bytes in the header as a number summing them using 1s complement. Each router compares this number with the checksum field, if they are not equal the datagram is discarded.
  *The checksum field should be calculated at every router and restored as the TTL field and options field may change.*
  TCP/UDP protocols also compute checksum over the entire TCP/UDP segment because they might be using a different protocol like ATM, while IP does because the data might be passed to other protocols.
- **Source and Destination IP address** : When the source creates the datagram it puts its address int he source ip addr field and dest ip addr in destination ip addr field.
- **Options** : This field allows IP header to be extended. Header options were meant to be used rarely but its mere existence complicate things. Because each datagram can have different length headers we can't know where the data begins beforehand. Also some datagrams having options would need processing. They were removed in IPv6 as discussed in [[4.4.1|Section 4.4.4]].
- **Data** : In most cases it contains the transport layer segment to be delivered however it can carry other types of data like ICMP messages discussed in [[4.4.3|Section 4.4.3]].

*An IP datagram consists of 20 byte header and if it is a TCP datagram then the datagram carries a total of 40 byte header(20 of ip header and 20 of tcp header) along with application message*.

#### IP Datagram Fragmentation
Not all link layer protocols carry network packets of the same size. For example ethernet can carry upto 1500 bytes of data while wide-area links can carry no more that 576 bytes. The max amount of data a link layer frame can transport is called the Maximum transfer unit(MTU) of the link layer protocol.
Because the link alter places a hard limit on the datagram size, if our datagram is larger we have to fragment it into two or more smaller fragment and then encapsulate them into separate link layer frame and send these over the outgoing link. Each of these smaller datagrams is referred as fragment.

Fragments needs to be reassembled before they reach the transport layer of the destination. Reassembling in the routers would introduce significant complications and put a damper on the routers performance, hence the designers of IPv4 decided to put the job of datagram reassembly in the end system rather than in the network routers.
When the destination host receives the series of datagram from the same source it needs to determine if these datagram are fragments of a larger datagram. If they are it needs to know when it receives the last fragment and also how to piece them back together. To allow the destination host to perform the reassembly, each fragment is sent with an identification, flag and fragmentation offset.

- **Identification** : The sending host stamps the identification number as well with the source and destination address, so when the destination host gets multiple datagram from the same source it can check the identification number to determine if they are a smaller fragment of a bigger datagram.
- **Flag bit** : This bit tells the destination host if the packet is the last packet. The last packet has the flag bit as 0, others have it as 1.
- **Fragmentation offset** : This helps the destination host to understand the order of fragments.
![[4.14.png]]
At the destination, the payload of the datagram is passed to the transport layer
only after the IP layer has fully reconstructed the original IP datagram. If one or
more of the fragments does not arrive at the destination, the incomplete datagram is
discarded and not passed to the transport layer.

A datagram of 4,000 bytes (20 bytes of IP header plus 3,980 bytes of IP payload) arrives at a router and must be forwarded to a link with an MTU of 1,500 bytes. This implies that the 3,980 data bytes in the original datagram must be allocated to three separate fragments (each of which is also an IP datagram). Suppose that the original datagram is stamped with an identification number of 777. The characteristics of the three fragments are shown in Table. The values in Table reflect the requirement that the amount of original payload data in all but the last fragment be a multiple of 8 bytes, and that the offset value be specified in units of 8-byte chunks.
![[ex3.png]]
**Risks** : Fragmentation comes at its own cost, it complicates routers an end systems which have to be designed to handle reassembly. It can also be used to create  DoS attack where an attacker sends a series of fragments but doesn't sent any fragment with flag 0. The target can collapse as it attempts to rebuild the datagram without knowing the last datagram. Another way it could be exploited is if the attacker sends datagrams which are not aligned properly. The target could crash if the OS doesn't know what to do of overlapping fragments. IPv6 does away with fragments making ip less vulnerable to attack.

### 4.4.2 IPv4 Addressing
A host has only one link into the network, IP sends and receives datagram through this link. The boundary between the host and the network is called the interface. A router's job is to receive datagram on one link and forward it to the other link, hence it has multiple interfaces.
Because each host and router is capable of sending and receiving datagram, each host and router should have an IP. Hence IP is associated with an interface rather than a host or router. 

Each IP is 32 bits long thus there are 2^32 or about 4 billion possible IP addresses. By approximation there are around 4 billion possible IP addresses. The IP address is usually written in dotted decimal notation, which consists of four decimal numbers separated by dots. Each decimal number represents 8 bits (1 byte) of the address and ranges from 0 to 255. For example the IP address 193.32.216.9 is represented in binary as 11000001.00100000.11011000.00001001.

![[Pasted image 20251016151747.png]]
The three host in the upper left portion and the router interface all have an interface of the form 223.1.1.xxx. These interfaces are interconnected to each other by a network without any routers In IP terms this is called a subnet. IP addressing assigns an address to this subnet : 233.1.1.0/24 where /24 is the subnet mask. It indicates that the left 24 bits out of the 32 bits define the subnet address. The remaining 8 bits are used to define the host address within the subnet.
z